# Uao Client for OPC UA SCA

# Contents

* [Background](#background)
* [C++ clients based on UaObjects](#uaobject-clients)
* [Software dependencies](#software-dependencies)
* [Examples](#examples)
* [Technical considerations](#technical-considerations)
* [References](#references)

## Background

There is a need for existence of C++-based OPC-UA clients which could be integrated into NSW DAQ software ecosystem, to be used primarily for calibration and configuration. Such clients would connect to the SCA OPC-UA server and request various SCA operations like ADC conversions, GPIO read/writes, SPI transactions etc.

## C++ clients based on UaObjects

The SCA-SW team publishes a C++ client which is generated by UaObjects in a gitlab repository [1].

A developer who needs to connect to an instance of SCA OPC-UA server to perform some SCA operations doesn’t need any knowledge about the OPC-UA itself or its software ecosystem. The generated client’s API is very SCA-specific; its body is composed of proxy functions which internally do all the OPC-UA business behind the scenes.

However, two (usually runtime) pieces of information are required to instantiate objects of the client:

* SCA OPC-UA server endpoint, typically looking alike: opc.tcp://hostname:port ( if  the discovery service is not used - basic use-case, likely valid until 2018Q2)

* object’s address in the SCA OPC-UA address-space, e.g. “sca-112.ai.voltage15”. It’s being discussed at the moment of writing of this documentation how the information will be disseminated.

## Software dependencies

In order to compile a client based on UaObjects one needs an OPC-UA client software stack with the API compatible with the Unified Automation C++ SDK. There are two alternatives to obtain such a SDK at CERN:

* Obtain the genuine UA SDK license
* Get the open-source open62541-compat module (another satellite of the quasar ecosystem) which provides a compatible API but internally uses open62541 (open-source OPC-UA stack) to deliver OPC-UA connectivity. The build instructions of open62541-compat along responsible contacts are documented in its github page [4]. The usage of open62541-compat based OPC-UA client for SCA has been proven as the moment of writing.

## Examples

A general example (as a demo program) is available at [5]. Please refer to it before moving on.

The crucial steps for the client available in [1] for e.g. ADC readout are the following (note the literals in bold are the server endpoint and object address, discussed above).

* Open an OPC-UA connection
UaClientSdk::UaSession* session;
session = ClientSessionFactory::connect("opc.tcp://test-server:4841");
(don’t forget to delete the “session" after use!)
* Instantiate a proxy object of an SCA Analog Input:
AnalogInput  aiTemperature (session, UaNodeId(“sca-112.ai.voltage15”,2));
* Request the read-out:
float temperature = aiTemperature.readValue();

## Technical considerations

Errors (e.g. server not reachable, object address invalid…) are generally thrown as std::runtime_exception with meaningful description. A notable exception to this rule is the invocation of  ClientSessionFactory::connect where a nullptr will be returned if a session can’t be opened.

The client code is currently not re-entrant due to limitations of open62541, but this is planned to improve. If you plan to call multiple operations on the same connection from different threads please wrap them in a mutex - or open multiple connections, the OPC-UA SCA server will easily handle them.

Synchronization: this is specific to given class and variable. Some examples:

* AnalogInput::readValue will always return the last value cached at the server (the server keeps on polling the ADC in the background). Therefore multiple invocations are likely to return the value of the very same conversion.
* An one-shot ADC mode has been suggested. When implemented, AnalogInput::readOneShot() would invoke a factual conversion (at the SCA level) and return when the conversion actually finished. Multiple invocations to readOneShot() will generally be blocking.
* SpiSlave::writeWrite would return only when the last reply from SCA is delivered. Multiple invocations will generally be blocking.

## References
1.  https://gitlab.cern.ch/atlas-dcs-opcua-servers/UaoClientForOpcUaSca
2.  https://github.com/quasar-team/UaoForQuasar
3.  https://github.com/quasar-team/quasar
4.  https://github.com/quasar-team/open62541-compat/
5.  https://github.com/quasar-team/UaoForQuasar/tree/master/demo