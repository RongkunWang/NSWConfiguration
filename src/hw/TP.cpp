#include "NSWConfiguration/TPInterface.h"

#include <iterator>
#include <stdexcept>
#include <string>

#include "NSWConfiguration/Constants.h"
#include "NSWConfiguration/OpcManager.h"
#include "NSWConfiguration/SCAInterface.h"
#include "NSWConfiguration/Utility.h"

nsw::hw::TP::TP(const TPConfig& config) :
  m_config(config), m_opcserverIp(config.getOpcServerIp()), m_scaAddress(config.getAddress())
{}

void nsw::hw::TP::writeConfiguration() const
{
  std::vector<std::pair<std::uint8_t, std::uint32_t>> list_of_messages = {
    {nsw::mmtp::REG_ADDC_EMU_DISABLE, static_cast<std::uint32_t>(true)},
    {nsw::mmtp::REG_L1A_LATENCY, static_cast<std::uint32_t>(m_config.ARTWindowCenter())},
    {nsw::mmtp::REG_L1A_WIN_UPPER, static_cast<std::uint32_t>(m_config.ARTWindowLeft())},
    {nsw::mmtp::REG_L1A_WIN_LOWER, static_cast<std::uint32_t>(m_config.ARTWindowRight())},
    {nsw::mmtp::REG_L1A_CONTROL, nsw::mmtp::L1A_RESET_ENABLE},
    {nsw::mmtp::REG_L1A_CONTROL, nsw::mmtp::L1A_RESET_DISABLE},
    {nsw::mmtp::REG_FIBER_BC_OFFSET, static_cast<std::uint32_t>(m_config.FiberBCOffset())},
    {nsw::mmtp::REG_INPUT_PHASE, static_cast<std::uint32_t>(m_config.GlobalInputPhase())},
  };

  if (m_config.GlobalInputOffset() != -1) {
    list_of_messages.emplace_back(nsw::mmtp::REG_INPUT_PHASEOFFSET,
                                  static_cast<std::uint32_t>(m_config.GlobalInputOffset()));
  }
  if (m_config.SelfTriggerDelay() != -1) {
    list_of_messages.emplace_back(nsw::mmtp::REG_SELFTRIGGER_DELAY,
                                  static_cast<std::uint32_t>(m_config.SelfTriggerDelay()));
  }
  if (m_config.VmmMaskHotThresh() != -1) {
    list_of_messages.emplace_back(nsw::mmtp::REG_VMM_MASK_HOT_THRESH,
                                  static_cast<std::uint32_t>(m_config.VmmMaskHotThresh()));
  }
  if (m_config.VmmMaskHotThreshHyst() != -1) {
    list_of_messages.emplace_back(nsw::mmtp::REG_VMM_MASK_HOT_THRESH_HYST,
                                  static_cast<std::uint32_t>(m_config.VmmMaskHotThreshHyst()));
  }
  if (m_config.VmmMaskDrainPeriod() != -1) {
    list_of_messages.emplace_back(nsw::mmtp::REG_VMM_MASK_DRAIN_PERIOD,
                                  static_cast<std::uint32_t>(m_config.VmmMaskDrainPeriod()));
  }

  for (const auto& [addr, msg] : list_of_messages) {
    writeRegister(addr, msg);
  }

  //
  // Fiber BC Offset. Each bit corresponds to a delay of 1 BC for each fiber.
  // Global 0xB knob. An overall global delay for all inputs w.r.t. the TP's FELIX-derived clock
  // Global 0xC knob. An overall global delay for half of inputs, in addition to 0xB
  // Self-trigger delay
  //

  // Once TP SCAX registers are autogenerated in NSWSCAXRegisters,
  // ... this model can be used. For the meantime, we're setting certain registers by hand.

  // std::map<std::string, I2cMasterConfig*> masters = m_config.getI2cMastersMap();
  // for (int i = 0; i < m_config.getNumMasters(); i++) {
  //   if (!masters[registerFilesNamesArr.at(i)])
  //     continue;
  //   ERS_LOG("Sending I2c configuration to " << tp_address << "."
  //                                           << masters[registerFilesNamesArr.at(i)]->getName());
  //   auto addr_bitstr = masters[registerFilesNamesArr.at(i)]->getBitstreamMap();
  //   std::vector<std::string> key_vec;
  //   for (auto regEntry : registerFilesOrderArr.at(i)) {
  //     key_vec.push_back(regEntry);
  //   }
  //   std::vector<std::string>::iterator it;

  //   for (auto ab : addr_bitstr) {
  //     it = std::find(key_vec.begin(), key_vec.end(), ab.first);
  //     auto registerAddress = nsw::intToByteVector(std::distance(key_vec.begin(), it), 4);
  //     auto address = tp_address + "." + masters[registerFilesNamesArr.at(i)]->getName() + "." +
  //     "bus" +
  //                    std::to_string(i);
  //     auto bitstr = std::string(32 - ab.second.length(), '0') + ab.second;
  //     auto data = nsw::stringToByteVector(bitstr);
  //     std::reverse(data.begin(), data.end());
  //     data.insert(data.begin(), registerAddress.begin(), registerAddress.end());
  //     for (auto d : data) {
  //       ERS_DEBUG(5, "data: " << static_cast<unsigned>(d));
  //     }
  //     DeviceInterface::SCA::sendI2cRaw(opc_ip, address, data.data(), data.size());
  //   }
  // }
}

std::map<std::uint8_t, std::vector<std::uint32_t>> nsw::hw::TP::readConfiguration() const
{
  throw std::logic_error("Not implemented");
}

void nsw::hw::TP::writeRegister(const std::uint8_t registerId, const std::uint32_t value) const
{
  const auto& opcconnection = OpcManager::getConnection(m_opcserverIp);
  const auto data =
    nsw::intToByteVector(value, nsw::NUM_BYTES_IN_WORD32, nsw::scax::SCAX_LITTLE_ENDIAN);
  const auto addr =
    nsw::intToByteVector(registerId, nsw::NUM_BYTES_IN_WORD32, nsw::scax::SCAX_LITTLE_ENDIAN);
  std::vector<std::uint8_t> payload(addr);
  payload.insert(payload.end(), data.begin(), data.end());

  ERS_DEBUG(3,
            "... writing to TP: address, message =  " << static_cast<int>(registerId) << ", "
                                                      << static_cast<int>(value));
  DeviceInterface::SCA::sendI2cRaw(opcconnection, m_scaAddress, payload.data(), payload.size());
}

std::vector<std::uint8_t> nsw::hw::TP::readRegister(const std::uint8_t registerId) const
{
  const auto& opcconnection = OpcManager::getConnection(m_opcserverIp);
  const auto addr =
    nsw::intToByteVector(registerId, nsw::NUM_BYTES_IN_WORD32, nsw::scax::SCAX_LITTLE_ENDIAN);
  return nsw::DeviceInterface::SCA::readI2cAtAddress(
    opcconnection, m_scaAddress, addr.data(), addr.size(), nsw::NUM_BYTES_IN_WORD32);
}
